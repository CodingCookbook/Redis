![](https://github.com/CodingCookbook/Redis/blob/main/File/gzh.png)

> 大家好，这里是**编程Cookbook**，关注公众号「编程Cookbook」，获取更多面试资料。本文详细介绍Redis的8种内存淘汰机制。

![](https://i-blog.csdnimg.cn/direct/7bcb5438a9b34401822b561640ea4dc5.png#pic_center)

---
>@[toc]

---
## 过期键删除策略

> 关注公众号「**编程Cookbook**」，获取更多编程学习/面试资料！


Redis 为管理内存，对设置了过期时间的键采用了以下三种删除策略：

1. **定时过期**：
   - **描述**：为每个设置了过期时间的键创建一个定时器，到达过期时间立即清除。
   - **优点**：对内存很友好，过期数据能及时清除。
   - **缺点**：需要消耗大量的 CPU 资源来处理定时器，影响缓存响应时间和吞吐量。

2. **惰性过期**：
   - **描述**：只有在访问某个键时才判断其是否过期，过期则清除。
   - **优点**：最大化节省 CPU 资源。
   - **缺点**：可能会有大量过期键未被访问而占用内存。

3. **定期删除**：
   - **描述**：每隔一定时间扫描 `expires` 字典中的部分键，清除过期键。
   - **优点**：折中策略，通过调整扫描时间间隔和每次扫描数量，平衡 CPU 和内存资源。

默认使用**惰性过期 (Lazy Expiration)和定期删除 (Periodic Deletion)** 两者结合的方式，能够在性能和内存使用之间找到一个良好的平衡。


## 内存淘汰机制

> 关注公众号「**编程Cookbook**」，获取更多编程学习/面试资料！


#### 内存限制设置
- Redis 可以通过参数 `maxmemory` 设置内存最大限制，从而避免 Redis 占满机器的内存，影响其他服务。
- **默认值**：
  - `maxmemory=0`，表示没有限制。
  - 在 **32 位系统** 上，Redis 最大支持内存为 3GB（32 位系统最大内存为 4GB）。
  - 在 **64 位系统** 上，Redis 的最大内存限制为物理机的可用内存。

Redis 的 `maxmemory` 参数和内存淘汰机制，使其成为一种有效的缓存方案，是 Memcached 的有效替代方案。


#### 常见策略
当内存达到 `maxmemory` 限制时，Redis 会按照 `maxmemory-policy` 启动相应的淘汰策略，Redis **默认**的内存淘汰策略是：**noeviction**。**常见策略**如下：

##### 1. 针对设置了过期时间的键
   - `volatile-lru`：仅对设置了过期时间的键，淘汰最近最少使用的键。
   - `volatile-ttl`：仅对设置了过期时间的键，淘汰剩余时间最短的键。
   - `volatile-random`：仅对设置了过期时间的键，随机淘汰。
   - `volatile-lfu`：仅对设置了过期时间的键，淘汰访问频率最低的键。

##### 2. 针对所有键
   - `allkeys-lru`：对所有键，淘汰最近最少使用的键。
   - `allkeys-random`：对所有键，随机淘汰。
   - `allkeys-lfu`：对所有键，淘汰访问频率最低的键。

##### 3. 无淘汰策略
   - `noeviction`：不进行淘汰，当内存超限时直接返回错误。

### Redis 3.0 的淘汰机制——近似 LRU 算法
| **策略**         | **含义**                 | **特性**                                                                 |
|------------------|-------------------------|--------------------------------------------------------------------------|
| `noeviction`    | **不淘汰**                 | 内存超限后写命令返回错误（如 OOM，`del` 命令除外）。                      |
| `allkeys-lru`   | 所有键的 `LRU` 淘汰       | 在所有键中按照最近最少使用（LRU）原则剔除键，释放空间。                  |
| `volatile-lru`  | 设置过期键的 `LRU` 淘汰   | 仅在设置了过期时间的键范围内按照 LRU 原则淘汰键（未设置过期时间则不淘汰）。 |
| `allkeys-random`| 所有键`随机`淘汰         | 在所有键中随机选择淘汰。                                                |
| `volatile-random`| 设置过期键`随机`淘汰     | 仅在设置了过期时间的键范围内随机选择淘汰。                                |
| `volatile-ttl`  | **设置过期键按 TTL 淘汰**   | 优先删除剩余时间（TTL）最短的键。                                        |


#### LRU（Least Recently Used）优化设计
Redis 的 LRU 算法经过优化，保证内存占用与淘汰效果之间的平衡，体现了工程实现中对 **空间与时间的折中**。

> **注意**：在主从复制模式（Replication）下，如果从节点达到 `maxmemory` 限制，不会记录任何异常日志，但增量数据无法同步到从节点。

---

##### 1. LRU 算法优化
- Redis 3.0 的 LRU 算法是**近似实现**，并非精确 LRU。
- 为了平衡内存占用与性能，Redis 在实现 LRU 时使用了 **采样方法**：
	- 默认从固定数量的键（由 `maxmemory-samples` 决定）中随机挑选一定数量的键进行比较，淘汰其中最符合 LRU 策略的键。
	- 默认采样值为 **5**，可以通过 `maxmemory-samples` 调整。
- **参数设置**：
	- 使用 `CONFIG SET maxmemory-samples <count>` 动态调整采样数量，采样越多越接近理论 LRU，但会增加性能开销。

##### 2. 近似 LRU 的特点
- **优点**：节省内存，只需记录部分键的访问信息。
- **缺点**：可能导致部分键未能准确淘汰，尤其在访问模式复杂时。
- **适用场景**：
	- 访问模式接近幂次分布时，近似 LRU 效果与理论 LRU 非常接近，几乎无差别。


##### 3. 近似 LRU 与理论 LRU 效果对比
![](https://i-blog.csdnimg.cn/direct/c19edee5be324ac0860983945998a086.png)


- 当数据访问模式接近幂次分布（大部分访问集中于少数键）时，近似 LRU 表现与理论 LRU 几乎无差别。



---

### Redis 4.0 的新增的淘汰机制——LFU 算法
#### 1. LFU 算法
- Redis 4.0 引入了 **LFU（Least Frequently Used）** 算法，专注于键的**访问频率**，而非最近访问时间。
- **LFU 的实现机制**：
	- 使用 **Morris counters**（一种稀疏计数器算法）记录访问频率，占用内存极小。
	- 计数器会随着时间衰减，以降低旧访问对频率统计的影响。
	- 提供参数配置计数更新频率和衰减速度，灵活控制缓存命中率。

#### 2. LFU 的特点
- **与 LRU 的对比**：
	- LRU：基于最近使用时间，适合短期缓存需求。
    - LFU：基于访问频率，适合长期缓存需求。
- **优点**：更适合评估键的整体重要性，避免 LRU 中因短期高频访问造成的缓存污染。
- **应用场景**：
    - 适用于需要长期保留高频访问键的场景，如热点数据。

#### 3. 相关策略
- `allkeys-lfu`：对所有键按 LFU 策略淘汰。
- `volatile-lfu`：仅对设置了过期时间的键按 LFU 策略淘汰。


> 关注公众号「**编程Cookbook**」，获取更多编程学习/面试资料！

